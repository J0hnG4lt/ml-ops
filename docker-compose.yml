version: "3.2"

services:
    rabbitmq-server:
        container_name: rabbitmq-server
        image: rabbitmq:3-management-alpine
        hostname: "rabbitmq-server"
        environment:
            RABBITMQ_ERLANG_COOKIE: "SWQOKODSQALRPCLNMEQG"
            RABBITMQ_DEFAULT_USER: "guest"
            RABBITMQ_DEFAULT_PASS: "guest"
            RABBITMQ_DEFAULT_VHOST: "/"
        ports:
            - "15672:15672"
            - "5672:5672"
        labels:
            NAME: "rabbitmq-server"

    influxdb:
        container_name: influxdb
        image: "influxdb:latest"
        restart: unless-stopped
        ports:
            - 8086:8086
            - 8083:8083
            - 2003:2003
        env_file:
            - ./src/influxdb/influxdb.env
        volumes:
            - ./volumes/influxdb/data:/var/lib/influxdb
            - ./src/influxdb/backups/influxdb/db:/var/lib/influxdb/backup

    chronograf:
        container_name: chronograf
        depends_on:
            - influxdb
        image: chronograf:1.8.4-alpine
        restart: unless-stopped
        user: "0"
        ports:
            - 8888:8888
        env_file:
            - ./src/chronograf/chronograf.env
        volumes:
            - ./volumes/chronograf/data:/var/lib/chronograf
            - ./volumes/chronograf/log:/var/log/chronograf

    grafana:
        container_name: grafana
        depends_on:
            - influxdb
        image: grafana/grafana:6.3.6
        restart: unless-stopped
        user: "0"
        ports:
            - 3000:3000
        env_file:
            - ./src/grafana/grafana.env
        volumes:
            - ./volumes/grafana/data:/var/lib/grafana
            - ./volumes/grafana/log:/var/log/grafana

    python-model-service:
        container_name: python-model-service
        build: ./src/python-model-service
        # 'rabbitmq-server' will be available as a network reference inside this service 
        # and this service will start only after the RabbitMQ service has.
        depends_on:
            - rabbitmq-server
        # Keep it running.  
        tty: true
        # Map port 8088 on the host machine to port 3000 of the container.
        ports:
            - "8088:8088"
        volumes:
            - './src/python-model-service:/python-model-service'
    
    webserver:
        image: puckel/docker-airflow:1.10.9
        restart: always
        depends_on:
            - postgres
            - redis
        environment:
            - LOAD_EX=n
            - FERNET_KEY=46BKJoQYlPPOexq0OhDZnIlNepKFf87WFwLbfzqDDho=
            - EXECUTOR=Celery
            - POSTGRES_USER=airflow
            - POSTGRES_PASSWORD=airflow
            - POSTGRES_DB=airflow
            - REDIS_PASSWORD=redispass
        volumes:
            - ./src/airflow/dags:/usr/local/airflow/dags
            # Uncomment to include custom plugins
            # - ./plugins:/usr/local/airflow/plugins
        ports:
            - "8080:8080"
        command: webserver
        healthcheck:
            test: ["CMD-SHELL", "[ -f /usr/local/airflow/airflow-webserver.pid ]"]
            interval: 30s
            timeout: 30s
            retries: 3

    flower:
        image: puckel/docker-airflow:1.10.9
        restart: always
        depends_on:
            - redis
        environment:
            - EXECUTOR=Celery
            - REDIS_PASSWORD=redispass
        ports:
            - "5555:5555"
        command: flower

    scheduler:
        image: puckel/docker-airflow:1.10.9
        restart: always
        depends_on:
            - webserver
        volumes:
            - ./src/airflow/dags:/usr/local/airflow/dags
            # Uncomment to include custom plugins
            # - ./plugins:/usr/local/airflow/plugins
        environment:
            - LOAD_EX=n
            - FERNET_KEY=46BKJoQYlPPOexq0OhDZnIlNepKFf87WFwLbfzqDDho=
            - EXECUTOR=Celery
            - POSTGRES_USER=airflow
            - POSTGRES_PASSWORD=airflow
            - POSTGRES_DB=airflow
            - REDIS_PASSWORD=redispass
        command: scheduler

    worker:
        image: puckel/docker-airflow:1.10.9
        restart: always
        depends_on:
            - scheduler
        volumes:
            - ./src/airflow/dags:/usr/local/airflow/dags
            # Uncomment to include custom plugins
            # - ./plugins:/usr/local/airflow/plugins
        environment:
            - FERNET_KEY=46BKJoQYlPPOexq0OhDZnIlNepKFf87WFwLbfzqDDho=
            - EXECUTOR=Celery
            - POSTGRES_USER=airflow
            - POSTGRES_PASSWORD=airflow
            - POSTGRES_DB=airflow
            - REDIS_PASSWORD=redispass
        command: worker

    # postgres:
    #     container_name: postgres
    #     image: postgres
    #     restart: unless-stopped
    #     env_file:
    #         - ./src/postgres/postgres.env
    #     ports:
    #         - 5432:5432
    #     volumes:
    #         - ./postgres/volumes/postgres/data:/var/lib/postgresql/data

    postgres:
        container_name: postgres
        image: postgres
        environment:
            - POSTGRES_USER=airflow
            - POSTGRES_PASSWORD=airflow
            - POSTGRES_DB=airflow
        # Uncomment these lines to persist data on the local filesystem.
        #     - PGDATA=/var/lib/postgresql/data/pgdata
        # volumes:
        #     - ./pgdata:/var/lib/postgresql/data/pgdata

    redis:
        container_name: redis
        image: redis
        command: redis-server --requirepass redispass

    portainer:
        container_name: portainer
        image: portainer/portainer
        restart: unless-stopped
        ports:
            - 9000:9000
        volumes:
            - /var/run/docker.sock:/var/run/docker.sock
            - ./volumes/portainer/data:/data
#     python-factory-service:
#         container_name: python-factory-service
#         build: ./python-factory-service
#         # 'rabbitmq-server' will be available as a network reference inside this service 
#         # and this service will start only after the RabbitMQ service has.
#         depends_on:
#             - rabbitmq-server
#         # Keep it running.  
#         tty: true
#         # Map port 3001 on the host machine to port 3001 of the container.
#         ports:
#             - "3001:3001"
#         volumes:
#             - './python-factory-service:/python-factory-service'

#     node-delivery-service:
#         container_name: node-delivery-service
#         build: ./node-delivery-service
#         # 'rabbitmq-server' will be available as a network reference inside this service 
#         # and this service will start only after the RabbitMQ service has.
#         depends_on:
#             - rabbitmq-server
#         # Keep it running.  
#         tty: true
#         # Map port 3001 on the host machine to port 3001 of the container.
#         ports:
#             - "3002:3002"
#         volumes:
#             - './node-delivery-service:/node-delivery-service'

        
    
# # Host volumes used to store code.
# volumes:
#     python-model-service: